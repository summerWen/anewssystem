<?xml version="1.0" encoding="UTF-8"?>
<chapter id="anews-ch-03">
    <title>我们要解决什么问题</title>

    <sect1>
        <title><anchor id="anchor.03.01"/>我们要解决什么问题</title>
        <para>将同类项目中的类似功能抽象出来，提供特定的解决方案，模板，以及工具类。</para>
        <para>让使用者可以通过：理解设计思想，参考模板实现，调用工具类三方面，更快的解决同类问题。</para>
    </sect1>

    <sect1>
        <title>数据字典</title>
        <para>数据字典是系统中一种常用的数据结构，主要特征有：</para>
        <orderedlist>
            <listitem>
                <para>对用户来说，只有“名称”这一个字段是有意义的</para>
            </listitem>
            <listitem>
                <para>数据字典的名称不能重复</para>
            </listitem>
        </orderedlist>
        <sect2>
            <title>NamedEntityBean.java</title>
            <programlisting><![CDATA[
package anni.core.domain;

import javax.persistence.Column;
import javax.persistence.Id;

public class NamedEntityBean {
    private Long id = null;
    private String name = null;

    @Id
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }

    @Column(unique = true, nullable = false)
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}]]>
            </programlisting>
            <para>pojo中定义id与name，注意在getName()使用的注释@Column(unique=true,nullable=false)，名称不能重复，不能为空。在插入的时候还应该判断不能为空字符串，也不能全是空格。</para>
        </sect2>
        <sect2>
            <title>NamedEntityDao.java</title>
            <para>dao中定义createOrGet方法，与其对应的是在前台显示的时候，要使用可以选择也可以输入的autocomplete输入框，与google的自动补完搜索框类似，既可以选择已有的数据字典，也可以输入一个新记录。</para>
            <programlisting><![CDATA[
    /**
     * 如果数据库中不存在指定name的记录，就将此条记录插入数据库，并返回对应的实体类.
     * 如果数据库中已经存在指定name的记录，就返回对应的实体类
     *
     * @param name 数据字典的name
     * @return T 返回对应的实体类
     *           当name为null或空字符串时，返回null
     *           当构造pojo实例时出现异常，也返回null
     */
    public T createOrGet(String name) {
        // 输入的名称不应该为空.
        if ((name == null) || "".equals(name.trim())) {
            return null;
        }

        String beanName = name.trim();
        List<T> list = findBy("name", beanName); // 这句是不是可以改成findByUnique？哪个效率更高？

        // 如果找到记录，应该是只有一项目，就返回这条记录的实体类
        if (list.size() > 0) {
            return list.get(0);
        } else {
            try {
                // 如果没找到记录，需要把这个数据字典保存进数据库
                // 需要pojo拥有空的构造方法
                T namedEntityBean = (T) getEntityClass().newInstance();
                namedEntityBean.setName(beanName);
                save(namedEntityBean);

                return namedEntityBean;
            } catch (InstantiationException ex) {
                System.err.println(ex);
            } catch (IllegalAccessException ex) {
                System.err.println(ex);
            }

            return null;
        }
    }]]>
            </programlisting>
        </sect2>
        <sect2>
            <title>应用场景</title>
            <para>产品录入界面，产品规格为数据字典，录入产品的时候，可以选择已有的规格，createOrGet()方法返回的是数据库中已有的记录。</para>
            <para>当出现之前从未录入的规格，不需要打开数据字典管理页面，添加新规格，只需要输入新规格名称，createOrGet()方法自动将此规格名称保存到数据库，并返回对应实例，进行关联。</para>
            <para>anni.anews.domain.NewsTag就是这种数据字典。</para>
        </sect2>
    </sect1>
    <sect1>
        <title>树形结构</title>
        <para>组织结构，系统菜单，产品分类，都是以树形显示的的数据结构，主要特征有：</para>
        <orderedlist>
            <listitem>
                <para>最少包括：id，名称，父节点id三个字段，如果需要排序，还要有排序字段。</para>
            </listitem>
            <listitem>
                <para>设计数据库表结构时，父节点id是自表关联的外键。</para>
            </listitem>
            <listitem>
                <para>可能有其他字段属性，不同级别下的名称可重复。</para>
            </listitem>
        </orderedlist>
        <sect2>
            <title>TreeEntityBean.java</title>
            <para><programlisting><![CDATA[
package anni.core.domain.tree;

import java.util.HashSet;
import java.util.Set;

import javax.persistence.Id;
import javax.persistence.Column;
import javax.persistence.CascadeType;
import javax.persistence.FetchType;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.MappedSuperclass;
import javax.persistence.OneToMany;
import javax.persistence.OrderBy;
import javax.persistence.Transient;


/**
 * id是Long的Tree类实现.
 *
 * @author Lingo
 * @since 2007-06-06
 * @param <T> 本身子表关联，T代表的就是本身的类型
 */
public class LongTreeEntityBean<T extends LongTreeEntityBean> {
    private Long id = null;
    private String name = null;
    private Integer theSort = null;
    private T parent = null;
    private Set<T> children = new HashSet<T>(0);

    @Id
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }

    @Column
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }

    @Column
    public Integer getTheSort() {
        return theSort;
    }
    public void setTheSort(Integer theSort) {
        this.theSort = theSort;
    }

    // 多对一关联
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "PARENT_ID")
    public T getParent() {
        return parent;
    }
    public void setParent(T parent) {
        this.parent = parent;
    }

    // 一对多
    // 查找children的时候，根据theSort正序排列，theSort相同时，根据id倒序排列
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "parent")
    @OrderBy("theSort asc,id desc")
    public Set<T> getChildren() {
        return children;
    }
    public void setChildren(Set<T> childrenIn) {
        children = childrenIn;
    }

    /**
     * @return 是否为根节点.
     */
    @Transient
    public boolean isRoot() {
        return parent == null;
    }

    /**
     * @return 是否为叶子节点.
     */
    @Transient
    public boolean isLeaf() {
        return (children == null) || (children.size() == 0);
    }

    /**
     * 不允许将自表外键关系设置成环状.
     * 就是说，当前bean的子节点中，如果包含entityBean，就不能把entityBean设置为当前bean的上级节点
     *
     * @param entityBean TreeEntityBean
     * @return boolean 是否形成环状
     */
    @Transient
    public boolean checkDeadLock(T entityBean) {
        return TreeHelper.checkDeadLock(this, entityBean);
    }
}]]>
            </programlisting></para>
            <para>包含了id主键，name名称，theSort排序编号，parent上级节点，children下级节点集合的pojo。并且提供了三个工具方法，isRoot()判断节点是否为根节点，isLeaf()判断节点是否为叶子节点，checkDeadLock(entityBean)判断pojo本身与作为参数传入的entityBean是否形成环形引用，避免把节点的parent关联到自己的子节点上。</para>
        </sect2>
        <sect2>
            <title>TreeEntityDao.java</title>
            <para>提供工具类，获得所有根节点的列表。</para>
            <para><programlisting><![CDATA[
    public List<T> loadTops() {
        return find("from " + getEntityClass().getName()
            + " where parent is null");
    }]]>
            </programlisting></para>
        </sect2>
        <sect2>
            <title>应用场景</title>
            <para>树形结构应用比较广泛，各种菜单，分类，部门结构都可以使用树形表示</para>
            <para>新闻发布中的新闻目录，权限管理中的部门，菜单都使用了树形结构。</para>
        </sect2>
    </sect1>

    <sect1>
        <title>extjs与springmvc结合，实现JsonTree</title>
        <para>TODO:</para>
    </sect1>

    <sect1>
        <title>extjs与springmvc结合，实现JsonGrid</title>
        <para>TODO:</para>
    </sect1>

    <sect1>
        <title>让extjs与acegi对接</title>
        <para>对接的目的是，保证前台绚丽的弹出登录窗口，登录成功后华丽的窗口消失效果，登录失败时也要漂亮的闪现错误提示，不要多次跳转。</para>
        <para>首先为了让acegi修改最少，使用ajax将帐号和密码提交到Filter中。这时候分四种情况考虑：</para>
        <orderedlist>
            <listitem>
                <para>首次登录成功，跳转到/sandbox/welcome.htm。返回已登录用户的真实姓名。</para>
                <para>接收json后进行的操作：打开左侧菜单，根据登录用户的信息，显示对应菜单。显示当前登录用户的真实姓名。</para>
            </listitem>
            <listitem>
                <para>首次登录失败，返回json格式的出错信息，可能为：用户不存在，密码错误，无法重复登录，验证码错误。</para>
                <para>这时候需要根据返回的错误信息，弹出alert对话框，或者suggest框。</para>
            </listitem>
            <listitem>
                <para>访问失败后，再次登录，验证后拥有此权限。</para>
                <para>打开左侧菜单，设置真实姓名，为iframe填充返回的页面信息。</para>
            </listitem>
            <listitem>
                <para>访问失败后，再次登录，验证后依然没有权限。</para>
                <para>打开左侧菜单，设置真实姓名，为iframe填充返回的错误信息。（这时候，其实是按照正常的URL去请求，不过因为没有权限，所以半路被拦截，变成了显示无权限的消息。）</para>
            </listitem>
        </orderedlist>
        <para>这样，每次无论成功失败。都要求返回的是json，改造AuthentikcationProcessFilter，将所有跳转命令都转向LoginController，在LoginController中构造json返回。</para>
        <para>因为只将登录的过程修改为返回json，所以覆盖successfulAuthentication()方法，将最后的sendRedirect()修改为转向LoginController.loginSuccess方法，同时把targetUrl需要跳转的URL附带上，在logingSuccess()里生成json，附带success:true登录成功标志，response:用户真实姓名，callback:iframe需要显示的URL。在js里处理后，完成整个对接过程。</para>
        <para>js方面，展开对话框，处理登录的代码分别在widgets/sandbox/index.js与widgets/lingo/form/LoginDialog.js中。不过真正发起检验登录的入口在needLogin.ftl中，在其中调用window.top.index.isLogin()，当注销的时候，也会跳转到needLogin.htm来触发登录事件。</para>
    </sect1>

</chapter>
