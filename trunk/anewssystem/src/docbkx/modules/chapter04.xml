<?xml version="1.0" encoding="UTF-8"?>
<chapter id="anews-ch-04">
    <title>技术手册</title>

    <sect1>
        <title>spring</title>
        <para>胶水技术，依靠DI黏合不同工具，让他们在一起运行。</para>
        <sect2>
            <title>在xml中使用spring-2.x的DTD。</title>
            <para><programlisting><![CDATA[<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN" "http://www.springframework.org/dtd/spring-beans-2.0.dtd">]]></programlisting></para>
            <para>相比schema真是方便了很多，这样可以在必须使用特定schema的时候，再让他重装上阵。</para>
            <para>spring-2.x中去掉了singleton属性，使用scope属性做替代。如果还想使用singleton属性，必须配置成spring-1.x格式的DTD。</para>
            <tip>spring中已不再推荐使用singleton属性，因为单例在多jvm，远程调用，集群的情况下难以掌控，还是为实例指明生存的scope比较好。</tip>
        </sect2>
        <sect2>
            <title>default-lazy-init</title>
            <para>懒惰加载，系统启动的时候并不加载xml中定义的bean，而是等到实际调用的时候才去加载，这样可以缩短系统初始化时间，在测试系统部分功能的情况下有极大的好处。</para>
            <para>注意，springmvc，xfire，quartz等的配置文件不能声明为懒惰加载，否则会出问题。</para>
        </sect2>
        <sect2>
            <title>default-autowire="byName"</title>
            <para>按名称自动绑定。设置了这个，只要定义bean的时候名称与需要绑定的属性名相同，在实例化对象的时候，spring就会将这些实例自动绑定，不需要再去声明绑定哪些property。减少xml代码量，使得结构更清晰。</para>
            <para>在使用compass的时候要注意，不能使用按名称自动绑定，会自动为compass绑定dataSource导致错误。</para>
        </sect2>
        <sect2>
            <title>import</title>
            <para>可以使用import导入多个配置文件</para>
            <para><programlisting><![CDATA[<import resource="classpath:spring/controller/admin-controller.xml"/>]]></programlisting></para>
            <para>这样可以把xml分成多个模块管理，如mail.xml里只配置邮件相关的配置。</para>
        </sect2>
        <sect2>
            <title>CharacterEncodingFilter</title>
            <para>spring提供的编码过滤器，好处一是不用自己动手写了，好处二是保证每次请求只过滤一次。配置如下：（web.xml）</para>
            <para><programlisting><![CDATA[
    <filter>
        <filter-name>encodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>UTF-8</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>encodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>]]>
            </programlisting></para>
        </sect2>
        <sect2>
            <title>IntrospectorCleanupListener</title>
            <para>spring提供的监听器，避免Struts，Quartz的内存泄露导致ClassLoader不能加载。配置如下：（web.xml）</para>
            <para><programlisting><![CDATA[
    <listener>
        <listener-class>org.springframework.web.util.IntrospectorCleanupListener</listener-class>
    </listener>]]>
            </programlisting></para>
        </sect2>
        <sect2>
            <title>PropertyPlaceholderConfigurer</title>
            <para>读取properties中的变量，在xml中可以通过${变量名}的方式调用。配置如下：</para>
            <para><programlisting><![CDATA[
    <bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
        <property name="locations">
            <list>
                <value>classpath*:conf/jdbc.properties</value>
                <value>classpath*:conf/hibernate.properties</value>
                <value>classpath*:conf/mail.properties</value>
            </list>
        </property>
    </bean>
    <bean id="foo" class="anni.Foo">
        <property name="test" value="${test}"/>
    </bean>]]>
            </programlisting></para>
        </sect2>
        <sect2>
            <title>PropertyOverrideConfigurer</title>
            <para>与PropertyPlaceholderConfigurer不同，PropertyOverrideConfigurer会在ApplicationContext初始化后，根据properties中的定义，修改对应属性的值。配置如下：</para>
            <para><programlisting><![CDATA[
    <bean id="testPropertyConfigurer" class="org.springframework.beans.factory.config.PropertyOverrideConfigurer">
        <property name="locations" value="classpath*:test/override.properties"/>
        <property name="ignoreInvalidKeys" value="true"/>
    </bean>]]>
            </programlisting></para>
            <para>用来在测试环境下覆盖已有的配置，比如在override.properties中有foo.test=111，那么id="foo"的bean的test属性就会被修改为111。</para>
        </sect2>
        <sect2>
            <title>spring-2.x对aop和事务管理的简化配置</title>
            <orderedlist>
                <listitem>
                    <para>首先要使用schema</para>
                    <para><programlisting><![CDATA[
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd
           http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd">]]>
                    </programlisting></para>
                </listitem>
                <listitem>
                    <para>然后要声明标记（不知道是不是必要的）</para>
                    <para><programlisting><![CDATA[
    <!-- 支持 @Transactional 标记 -->
    <tx:annotation-driven/>

    <!-- 支持 @AspectJ 标记-->
    <aop:aspectj-autoproxy/>]]>
                    </programlisting></para>
                </listitem>
                <listitem>
                    <para>配置aop</para>
                    <para><programlisting><![CDATA[
    <aop:config proxy-target-class="true">
        <aop:advisor pointcut="execution(* anni.anews.manager..*Manager.*(..))" advice-ref="txAdvice"/>
        <aop:advisor pointcut="execution(* anni.anews.dao..*Dao.*(..))" advice-ref="txAdvice"/>
        <aop:advisor pointcut="execution(* anni.core.dao..*Dao.*(..))" advice-ref="txAdvice"/>
    </aop:config>]]>
                    </programlisting></para>
                </listitem>
                <listitem>
                    <para>配置txAdvice处理事务</para>
                    <para><programlisting><![CDATA[
    <tx:advice id="txAdvice">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="find*" read-only="true"/>
            <tx:method name="pagedQuery*" read-only="true"/>
            <tx:method name="load*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>]]>
                    </programlisting></para>
                </listitem>
            </orderedlist>
            <tip>
              <para>name-pattern千万不要写成*..*Manager ，这样子会把所有第三方类库的Manager比如Spring的PlatformTranstationManager 也加入aop，非常危险。所以最好还是加上项目的package前缀，如"anni.anews..*Manager"</para>
              <para> 因为有*，会修饰所有方法，有些hibernateTemplate的final的方法不能被cglib修改，会抛warning，无害。</para>
            </tip>
        </sect2>
    </sect1>

    <sect1>
        <title>hibernate</title>
        <para>感觉是目前最成熟的ORM框架，家族中新添了hibernate-shards支持多数据库访问，hibernate-search提供全文检索，大有潜力可挖。</para>
        <sect2>
            <title>基于annotation的JPA式配置</title>
            <para><programlisting>
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratorType;
import javax.persistence.Id;

@Entity
public class Test {
    private Long id;
    private String name;

    @Id(generate = GeneratorType.AUTO)
    public Long getId() {
        return id;
    }
    public void setId(Long id) {
        this.id = id;
    }
    @Column
    public String getName() {
        return name;
    }
    public void setName() {
        this.name = name;
    }
}
            </programlisting></para>
            <tip>如果pojo要定义getter方法，这个方法数据库的持久字段没有关联，必须使用@Transient标注，否则hibernate会把它当作一个持久字段，去数据库读取的时候会报错。</tip>
        </sect2>
        <sect2>
            <title>一对多</title>
            <para>见anni.anews.domain.NewsCategory</para>
        </sect2>
        <sect2>
            <title>多对多</title>
            <para>见anni.anews.domain.News和anni.anews.domain.NewsTag</para>
        </sect2>
        <sect2>
            <title>继承</title>
            <para>尚未用到。之前用过一次，一表多类，不知如何直接取得子类数据。</para>
        </sect2>
    </sect1>
    <sect1>
        <title>acegi权限管理</title>
        <para>照搬springside-2.0的权限模型，实现User用户 - Role角色 - Resource资源三种组成的RBAC模型。</para>
        <para>稍微注意一下，默认角色名称都要以ROLE_开头，否则不会被计入权限控制，如果需要修改，就在xml里配个什么前缀的。</para>
        <sect2>
            <title>使用Filter拦截URL请求</title>
            <para>使用在web.xml中配置的一系列filter实现对URL请求的拦截。</para>
        </sect2>
        <sect2>
            <title>使用interpreter拦截METHOD调用</title>
            <para>采用aop方式，实现方法调用拦截。</para>
        </sect2>
        <sect2>
            <title>ACL如何实现？</title>
            <orderedlist>
                <listitem>
                    <para>根据springside的JIRA描述，实现基本的层次式ACL 管理，（Role A拥有部门A的审批，部门B的查看权限, 请假单属于部门A，则Role A有该单的审批权限）。与插件式的规则引擎管理。</para>
                </listitem>
                <listitem>
                    <para>来自： <ulink url="http://www.blogjava.net/RongHao/archive/2006/12/14/87634.html"/>对acegi ACL扩展的构想</para>
                    <para>扩展一：当你增加一条记录的同时向ACL表里插入权限信息，这个ss已经做到了，ss有一个借口标记那些domain需要ACL保护AclDomainAware。这里再扩展一个基类，目的很简单，当读出数据时附加上权限信息 <programlisting><![CDATA[
public class BasicAclDomain implements AclDomainAware {
    private int mask; // 权限
    getMask
    setMask
}

public class Contact extends BasicAclDomain]]>
                    </programlisting></para>
                    <para>扩展二：读取列表时进行数据过滤，原来的acegi在ACL的集合后处理会造成分页虎牙子。这里采用前拦截，在acl表里增加一个className字段，里面放上PO的类名，这样可以缩小数据查询范围。实际在读取集合时，先到acl表里完成分页，然后多的对contact的real id list，然后拦截实际DAO方法，动态改变SQL成select * from real_data where id in ({real id list})的形式。</para>
                    <para>分页实际是对acl表里相应记录的分页，比如说取第10条到20条，实际是取acl表里响应记录的第10条到20条来动态改变sql。</para>
                    <para>这个可以写一个专门用来拦截的类SecurityDAO方法，findByPageACL(query, page),ContactServiceImpl中getAllContacts方法强制调用该方法。</para>
                    <tip>这个方法在javaeye中看到了讨论，问题就在于：real id list过大时，数据库会将sql剪切。所以数据量大的时候没法用，还有人说如果需要动态设置其他查询或排序条件，还会有问题，具体是什么就没说，可能是解析出问题，或者效率问题</tip>
                    <para>扩展三：后拦截。这里AFTER_ACL_COLLECTION_READ和AFTER_ACL_READ的目的就很简单了，因为他们不再进行数据过滤，他们只是把用户对每条记录的mask取最大权限就OK了，然后往PO级setMask。这样PO带了权限信息到页面上行就非常好处理了。比如button的显示等等。</para>
                    <para>扩展四：封装AclService，对单条记录的ACL权限管理。比如增加权限，修改权限，删除权限。这个acegi从1.0.3已经开始加入了。</para>
                    <para>还未实现的构想一：PO创建向ACL表里插入权限信息时，可以配置不同策略：比如通讯录创建一条新信息只能创建者可以看并管理，儿你往请假表里插入一条新信息后，不仅你了，你的上司也可以同时看到。（这个还是比较easy的）。</para>
                    <para>还未实现的构想二：用户数据要实现数据库排序。需要在ACL_OBJECT_IDENTITY里增加几个额外字段，把PO相应的排序字段同步更新到ACL表中。什么？不好做？写配置文件啊！再对PO的update进行后拦截，想法就这样。实现？？</para>
                </listitem>
            </orderedlist>
        </sect2>
    </sect1>
    <sect1>
        <title>springmvc</title>
        <para>PrototypeController基于springside-1的思想，对controller进行封装，采用spring-2.x提供的惯例配置的同时，将controller改造成每个请求生成一个实例的形式，这么做主要是为了省略方法中的HttpServletRequest和HttpServletResponset两个参数，将controller改造成jsp里那样，可以直接获得request, response, session, application, mv几个默认参数，无需每次手工创建。</para>
        <para>ExtendController在这基础上提供了getLongParam(), getStrParam()几个帮助方法，方便快捷获得请求的参数。getLongParam("name", defaultValue)都可以设置默认值，在参数不存在的情况下自动返回默认值，不必担心NumberFormatException之类的错误，方法内已经做了自动处理，进一步简化操作。</para>
        <para>BaseController是在ExtendController的基础上，基于generic范型封装的基类，子类继承它即可获得CURD操作。</para>
        <para>JsonController也是在ExtendController基础上进行封装，默认为ModelAndView设置不渲染view，在controller中直接生成json字符串，写入到response.getWriter()中。</para>
    </sect1>
    <sect1>
        <title>extjs</title>
        <para>js控件库，可选择基于yui,prototype,jquery或者ext-base底层实现，在这些底层基础上构筑了丰富的组件库。采用oo风格封装，易于使用和扩展。</para>
        <para>目前主要封装了Ext.lingo.JsonTree和Ext.lingo.JsonGrid，采用json格式的数据与后台交互，实现CURD等通用功能。</para>
        <sect2>
            <title>Ext.lingo.JsonTree</title>
            <para>树形结构，适用于单表自关联结构。</para>
            <orderedlist>
                <listitem>
                    <para>异步读取节点（不过管理分类的时候需要读取所有节点）</para>
                </listitem>
                <listitem>
                    <para>双击节点编辑节点内容</para>
                </listitem>
                <listitem>
                    <para>拖拽排序</para>
                </listitem>
                <listitem>
                    <para>右键弹出菜单，进行详细配置</para>
                </listitem>
            </orderedlist>
        </sect2>
        <sect2>
            <title>Ext.lingo.JsonGrid</title>
            <para>实现CURD功能的表格。</para>
            <orderedlist>
                <listitem>
                    <para>数据库端分页</para>
                </listitem>
                <listitem>
                    <para>checkbox全选，多选行</para>
                </listitem>
                <listitem>
                    <para>按字段模糊搜索</para>
                </listitem>
                <listitem>
                    <para>弹出对话框，进行新增或修改数据</para>
                </listitem>
            </orderedlist>
        </sect2>
    </sect1>
    <sect1>
        <title>测试与代码分析</title>
        <sect2>
            <title>spring-mock</title>
            <para>使用spring-mock提供的几个超类非常有好处，spring提供了可以一次读取xml并缓存的机制，让所有testCase都可以共享同一份applicationContext，大大加快了测试速度。</para>
            <para>需要注意的是获得ctx缓存的key是根据getConfigLocation()获得的，如果在子类中覆盖了这个方法，返回不同的数值，会导致重新加载。同样的如果不覆盖方法返回不同值，那么使用的都是同一份ctx。</para>
        </sect2>
        <sect2>
            <title>cobertura</title>
            <para>因为1.8版本的一漏洞，每次生成覆盖率报表都是100%。幸好现在的1.9已经解决了这个问题，不过对应的maven2-plugin还没有发布，尝试2.2-snapshot插件使用cobertura-1.9，感觉功能与clover已经很接近了，而且配置也方便。</para>
        </sect2>
        <sect2>
            <title>代码分析</title>
            <para>大体分成三方面</para>
            <orderedlist>
                <listitem>
                    <para>checkstyle检查源代码的编码风格，检查javadoc是否完整，缩进，空格是否一致。用来检查大家是否遵循同一种编码规范。</para>
                </listitem>
                <listitem>
                    <para>findbugs是检查编译后的class是否存在隐性bug，包括无用代码，不好的实践等等。</para>
                </listitem>
                <listitem>
                    <para>pmd与findbugs功能相似，与其一起工作的cpd可以检查代码中是否存在大量重复代码，如果重复代码过多，就说明代码应该重构了。提出重复代码部分，做成工具类，或者抽象出超类来。</para>
                </listitem>
                <listitem>
                    <para>jdepend用来检验代码依赖和复杂度，暂时不太会用。报表中可以显示当前代码都与哪些包关联。</para>
                </listitem>
            </orderedlist>
        </sect2>
    </sect1>

</chapter>
